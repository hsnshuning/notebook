问题
    当进程被阻塞时，是谁把进程放进阻塞队列的？

职责不同分类
    长期调度
        长期调度负责选择批处理任务，创建创建进程，完成创建转为预备状态后将进程放入运行队列。交互任务和实时任务要求实时性，系统直接创建进程不需要长期调度参与。

    中期调度
        当系统内存资源紧张而触发换页机制时，中期调度会把预备/阻塞状态中的进程挂起，状态置为挂起预备/挂起阻塞状态并放入挂起运行队列/挂起阻塞队列
        当系统内存资源不紧张时，中期调度会将挂起运行队列/挂起阻塞队列中的进程激活，并将其放入运行队列/阻塞队列
        当挂起阻塞状态的进程等待的事件被触发了，会置为挂起预备状态，放入挂起运行队列

    短期调度
        短期调度通过调度策略，从运行队列中拿进程放到CPU上去执行，把进程置为运行状态
        当进程在CPU上运行了一个完整的时间片后，把这个进程放回运行队列，把进程置为预备状态
        当进程被阻塞放入阻塞队列时，短期调度选择其他进程进行调度。

    操作系统调度（自己加的）
        交互任务和实时任务要求实时性，系统直接创建进程，置为预备状态放入运行队列，不需要长期调度参与。
        当进程需要被阻塞时，操作系统把进程置为阻塞状态放入阻塞队列。
        当阻塞进程等待的事件触发后，操作系统会将阻塞进程修改为预备状态，从阻塞队列移到运行队列

    图例

单核调度策略
    到达时间
        表示该任务何时被发起并处于预备状态

    运行时间
        表示该任务从开始到执行结束共花费多少时间

    周转时间
        程序从进入系统到完成的时间的总量，作业完成时间-作业提交时间

    平均周转时间
        一段时间内到来的任务，他们的平均周转时间。（作业周转时间1+作业周转时间2+...+作业周转时间N）/N

    单核调度器需要考虑的问题
        当前应该调度哪个任务
        被调度的任务应该执行多久

    经典调度
        非抢占式调度
            先到先得（First Come First Served，FCFS）
                思想
                    哪个先到就先执行哪个，执行完或阻塞再执行下一个，简单直观

                缺点
                    在长任务后到达的短任务周转时间长。对长短任务混合场景下的短任务不友好，比如短任务只需要执行1ms，而前面排了10个长任务一个要1秒，短任务就要等待前面的10个长任务执行完才能执行，周转时间太长了。
                    对IO密集型任务不友好。比如有一个计算任务A要执行40S，一个IO任务B等待IO执行，B先于A进入了队列，先使用了5秒CPU时间然后等待IO请求陷入了阻塞，这时候A执行，B需要等到A执行完成后，也就是40秒之后才能再次获得CPU，即使等待的事件已经触发了也不行。


            最短任务优先（Shortest Job First，SJF）
                思想
                    为了解决先到先得方式中对短任务不友好的弊端，短任务优先算法在调度的时候选择运行时间最短的任务来调度。

                弊端
                    严重依赖任务到达的时间。比如 ABC三个任务分别在0，1，2秒到达，A执行40秒，BC分别执行1秒，这时候因为A是先到的，调度器会调度A任务，BC还是要等到A结束之后再执行。
                    必须预知运行时间。能够使用最短任务优先的调度方式的一个核心在于任务的运行时间是已知的，但提前预知任务的运行时间是不现实的，因为运行时间取决于当前系统和设备等的状态。



        抢占式调度
            最短完成时间优先（Shortest Time-to-Completion First，STCF）
                思想
                    为了解决短任务优先方式对于后到达的短任务不友好的问题，提出了任务到达时重新进行调度，把短任务优先进行调度，从而解决短任务周转时间太长的问题

                弊端
                    长任务饥饿



        时间片轮转（Round Robin）
            思想
                上述抢占式和非抢占式调度策略中考虑的都是批处理任务，对于批处理任务来说周转时间越少体验越好，但是对于交互式任务来说，响应时间越少体验才越好，针对于响应时间来考虑调度策略提出了时间片轮转策略，该策略限制任务每次执行的时间，时间片足够小时所有任务都可以在一定时间内给用户响应，并且该策略不会出现长任务饥饿

            缺点
                任务的平均周转时间长


        优先级调度
            思想
                为了区分交互式和批处理任务，调度器引入了优先级概念，为没个任务指定一个优先级，调度器就可以确定哪个任务应该先执行。

            多级队列（Multi-Level Queue，MLQ）
                多级队列为每个任务预先分配好优先级，每个优先级一个队列，调度器先调度高优先级队列中的任务。处于同一优先级队列的任务，可根据场景使用不同策略，如FCFS或RR。
                多级队列适用于可以根据任务信息（如大致执行时间，占用资源情况等）生成调度模型，计算出每种任务适合的优先级以进行调度。
                多级队列会导致低优先级任务饥饿

            多级反馈队列（Multi-Level Feedback Queue，MLFQ）
                为每个队列设置最大运行时间。任务进入时先假设为短任务，分配最高优先级。当任务执行总时间达到最大时间，认为该任务的执行时间较长，将该任务放入低一级的队列。
                先执行高优先级任务会造成低优先级任务饥饿，为了防止饥饿MLFQ在一定时间周期后将系统内所有任务的优先级都调至最高。
                需要看一下126页多级反馈队列流程，PDF模糊看不清
                多级反馈队列优化门槛高，调整的参数比较多，需要对系统足够熟悉才可以达到预期效果，否则可能退化为RR等策略




