# POSIX线程接口
1. 创建：pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
    * pthread_create创建线程的能力是通过clone来实现的。
    

问题
    为什么需要引入线程?
    拥有多个线程的进程的虚拟地址空间结构是怎样的?
    用户态线程与内核态线程的区别和联系分别是什么?
    针对线程的核心操作有哪些?

多线程地址空间布局
    内存布局图
    线程栈
        每个线程有自己的线程栈来存放临时数据。

    内核栈
        因为调度的最小粒度为线程，所以每个线程有对应的内核栈，当线程陷入内核态时执行对应的内核栈。

    共享部分
        除了栈意外其他区域所有线程共享，包括堆，数据段，代码段，代码库等等。


用户态线程
    用户态线程是由用户态应用创建的线程，内核不可见，不直接受系统调度器管理。用户态线程更轻量级，创建开销小，但功能受限，当操作需要进行系统调用时需要内核态线程的协助来执行。

内核态线程
    内核态线程是由内核创建与管理的，受操作系统调度器直接管理。

多线程模型
    多线程模型表示内核态线程与用户态之间的关系
    1：1关系表示一个用户线程对应一个内核线程，是现在的主流，linux和windows都采用这种模型
    1：n关系表示1个内核线程对应多个用户线程，因为不能很好适应多核已经被淘汰
    n：m关系表示n个用户线程对应m个内核线程，且内核线程比用户线程少，一般是多少个核就有多少个内核线程，这种模型在1：n和1：1之间权衡，但是这种模型让内核态线程的管理变复杂了。GCD调度器采用这种模型。

线程控制块（Thread control Block，TCB）
    用于保存自身信息， 内核态线程和用户态线程各自有自己的TCB，内核态TCB保存的与PCB相似，存储线程的运行状态、内存映射、标识符等信息，用户态TCB可以看做是内核态TCB的扩展，具体存储什么信息主要由使用哪个线程库决定。用户态TCB一项重要的功能是线程本地存储。

线程本地存储（Thread Local Storage，TLS）
线程上下文
    线程上下文存储了线程执行中的状态，即寄存器中的值，包括存储CPU当前执行的指令的地址的程序计数器（PC），存储CPU当前正在处理的一些数据的通用寄存器，存储CPu当前欧的一些硬件状态和配置如页表等的特殊寄存器。

