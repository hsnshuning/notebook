作用
    虚拟内存能够使程序独立而连续的使用虚拟地址空间，通过页表与硬件的配合在对程序透明的前提下自动进行虚拟地址到物理地址的翻译。除此之外，基于虚拟内存，还可以提供共享内存、写时拷贝、内存去重、内存压缩、大页等功能。

共享内存
    共享内存允许两个应用程序共享一个物理页。程序A的虚拟地址A1映射到物理页X，程序B的虚拟地址B1同样映射到X，他们可以共享这个物理页X的数据，可以修改X的数据。基于共享内存，可以实现程序之间的通信。

写时拷贝
    写时拷贝是为了节省内存资源而让两个进程共用一段内存，例如多个程序使用相同的动态链接库、通过fork创建子进程。
    两个程序使用相同的动态链接库时，会把两个程序依赖的动态链接库的虚拟页映射到相同的物理页。
    通过fork创建子进程时，被创建的子进程是和父进程共享物理内存的，页表项中有管理程序对虚拟页权限（是否可写，是否可执行）的标识，fork之后父子进程对内存页的权限都为只读，其中任何一个进程如果对内存进行修改，操作系统都会发现违反了权限，从而触发缺页中断，操作系统会执行缺页中断处理函数，该函数中会发现缺页中断是因为权限问题导致的，而这个内存页正好是被标记成写时拷贝的内存页，操作系统就会把物理内存中对应的页拷贝一份，将拷贝的物理地址重新映射到触发异常的程序。

内存去重
    基于写时拷贝机制，操作系统可以为物理内存页进行去重。操作系统可以定期扫描具有相同内容的物理页，并且找到映射这些物理页的虚拟页，保留其中一个物理页把其他的物理页释放，把所有虚拟页都映射到这个物理页上，在需要对该页进行修改时再通过写时拷贝重新拷贝，从而降低了内存的使用。linux中该功能称为KSM（Kernel Same-page Merging）。
    因为该功能会在修改页面时触发写时复制，导致触发缺页中断以及内存拷贝，所以可能会导致性能下降。
    该功能也可能会导致发生安全问题。攻击者可以在内存中通过穷举的方式不断构造数据’然后等待操作系统去重，再通过访问延迟确认是否发生了去重。若访问延迟变长，则表明整个系统中存在相同的数据，因此攻击者可以通过这种猜测的方式去确认系统中是否存在某些敏感数据。一种防御这种攻击的可能方法是：操作系统仅在同一用户的应用程序内存之间进行内存去重，从而使得攻去者元法猜测别的用户的应用程序中的数据。

内存压缩
    当物理内存不足时，操作系统会选择一些页来触发换出操作，因为换出操作是磁盘IO，所以不管是换出，还是将来的换入，带来的性能损耗都很大，所以大哥们想到了把这些页打包压缩，在物理内存中专门找一个地方来存储这些压缩后的数据，再需要用这些页的时候就从这个压缩区域拿出来解压后使用，从而减少换出操作，即使最后触发换出操作，换的数据也是压缩后的数据，数据量会明显减小，对性能的影响也会明显减少。

大页
    大页是为了提高TLB的缓存命中率，针对特定场景提供的优化。如果开启该功能，页表项指向的地址可能就不是一个4k大小的页面了，可能是2m，可能是1g大小的页面，这样的话一个TLB缓存项由原来映射4k页面的能力变为了映射2M，映射1G的能力，所以对于频繁访问大内存的应用可以起到优化TLB命中率的作用。
    为什么大页可以提升数据库性能

