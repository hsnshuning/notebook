管理目标
    减少内存的内部碎片和外部碎片
    尽可能降低分配延迟，节约CPU资源
    外部碎片
        在被分配使用的内存之间出现的无法再进行分配的内存碎片
        解决外部碎片问题的方法是将内存以固定大小进行分配

    内部碎片
        因为解决外部碎片问题，我们要分配等长的空间，那必然会出现可能我只需要1byte，但是分配了2byte内存的场景，就有1byte被分配给我的内存没有用到，这种分配的空间大于实际需要的空间，就是内部碎片


伙伴系统（buddy system）
    作用
        伙伴系统解决了物理页维度的内存分配。伙伴系统把物理内存划分为连续的块，每个块由1个或多个物理页构成（数量为2^{n}个物理页，0\leqslant n<预设max）。

    分配过程
        当请求分配m个物理页时，伙伴系统将分配2^n个物理页且满足2^{n-1}<m\leqslant 2^{n}。
        在分配过程中如果当时没有符合分配条件的块，就从更高级的块中，将一个块分裂成两个块，直到分裂出符合条件的块。分裂出的块，一个用于分配给请求，其他的块加入对应级别的块链表等待分配。分裂期间，每个大块分裂出的两个小块之间的关系就是伙伴关系。
        当一个块被释放后，分配器会找到这个块的伙伴块， 伙伴块如果也空闲的话，两个块就会合并成一个更高级的块，如果还能合并就继续合并。
        如何确定两个块互为伙伴块呢？假设块大小为8k，即2^{13}，那起始地址只有第13位不同的两个块，就是互为伙伴块，如0x0000和0x2000互为伙伴块，还有0x4000和0x6000也互为伙伴块。根据起始地址，操作系统可以快速找到互为伙伴块的两个块，所以伙伴系统可以快速高效的管理物理内存页。


SLAB分配器
    作用
        伙伴系统提供了物理页维度的内存快速高效的分配和释放问题，但是对于平常使用的程序来讲，可能一次分配也就是使用几十几百字节，按一个物理页4k的大小来进行分配还是非常大，需要一个以字节维度来管理小对象分配和回收的策略。

    SLUB
        SLUB分配器简化了SLAB分配器的设计和数据结构，降低复杂度的同时提供相当甚至更好的性能。
        设计思路
            结构
                SLUB分配器从伙伴系统申请一块内存，再将伙伴系统分配的内存块再继续细分，细分的也是一些固定大小的内存块，大小通常是2^{n}byte，这样细分一方面是因为操作系统频繁分配的对象大小相对固定，另一方面是为了避免出现外部碎片。每一种块大小都对应着一个独立的资源池，SLUB使用独立的资源池进行分配。
                申请到的内存块叫做一个slab，把一个slab的内存块细分为多个等长的小内存块，把内部空闲的小内存块组成链表。
                一个资源池有current和partial两个指针，current指向最近使用的一个slab，partial指向有空闲块的slab组成的链表。

            分配
                当SLUB分配器收到一个分配请求，先找到跟分配大小最接近的资源池，然后从current指针指向的slab拿一个空闲内存块返回即可。如果current指向的slab已经没有空闲内存块了，就从partial指向的链表取出一个slab给current指针，如果partial指针指向的链表为空了，就从伙伴系统再申请新的内存块，作为新的slab。

            释放
                当SLUB分配器接收到一个释放请求，将被释放的块放入相应的slab的空闲链表中，如果slab原本没有空闲块了，就将这个slab移动到partial中，如果slab原本只有一个块被用到了，回收之后这个slab就都空闲了， 这时候把这个slab还给伙伴系统，释放这块内存空间。
                slab头部会



    SLOB
        SLAB分配器家族中还有—种最简单的分配器称为SLOB分配器，它的出现主要为了满足内存资源稀缺场景(比如嵌人式设备)的需求，它具有最小的存储开销，但在碎片问题的处理方面比不上其他两种分配器。释放块如何定位到slab？


空闲链表
    隐式空闲链表
        所有的内存块都保存在一个链表中， 每个内存块的头部存有这个块是否被分配以及块大小这些信息，通过块的头信息，可以快速判断这个块是否符合分配条件，不符合分配条件可以快速跳到下一个块继续判断。
        如果找到了第一个大小足够的块，就把这个块分配给请求，当这个块被分配了之后还有足够大的剩余空间，就把这个块进行分裂，一部分用于请求，一部分作为空闲块。这样尽可能的利用内存空间，缓解内部碎片问题。
        在释放内存时，为了尽可能避免外部碎片问题，会检查这个内存块两边的块是否空闲，如果处于空闲状态，会把这些快进行块合并，产生一个更大的块

    显式空闲链表
        仅把空闲块放在链表上，因为没法通过块大小去计算下一个块的地址，所以需要维护prev和next指针，因为只需要在空闲块中维护这两个指针，所以不需要一个专门的头，用数据部分就可以，不会因为指针占用额外空间。
        分配和释放与隐式类似

    分离空闲链表
        基于显式空闲链表方式，与SLUB分配器相似。在显式基础上，为每个固定内存块大小维护一条链表。
        分配时找到对应大小的链表，取出第一个空闲块，如果没有空闲块就去更大的链表中去找。
        释放时分配器可以先采用单条显式的合并策略，然后将合并产生的块插入对应大小的空闲链表中。


