基本思想
    分页机制的基本思想是将程序的虚拟地址划分为连续的，等长的虚拟页，物理地址也划分为连续的，等长的物理页，虚拟页和物理页的页长固定且相等，

页表
    作用
        把虚拟地址映射为物理地址，页表的起始地址存在页表基地址寄存器中

    页表页
        一个页表可能是由多个页组成的，用于页表的一个页就叫做页表页

    页表项
        页表中每一个映射关系，叫做页表项


单级页表
    存在的问题
        页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框
            假设我们的虚拟地址空间是32位，即2^{32}最大4G内存，一个页表项可以表示4K地址空间，总共需要1M的页表项，一个页表项占用4byte，最后得出一个程序启动就需要分配4*1M的连续空间存放页表项。
            引入多级页表来让原来需要分配的连续的页框离散化以解决这个问题

        没必要让整个页表常驻内存
            引入虚拟存储技术，在需要访问页面时才把页面调入内存。在页表项中增加是不是在内存中的标志位。



多级页表
    作用
        个人理解其实是把单级页表类似数组的结构转换为了类似于树的结构吧，所以可以实现页表页的离散分配和根据需要分配。
        ｜ 多级页表虽然解决了单级页表内存分配的问题，解决方案也非常巧妙的平衡了时间和空间消耗，但也确实让翻译变慢了，就是分了多少级页表，就需要n+1次访问才能拿到数据。
        解决单级页表必须一次性生成所有页表页所造成的内存浪费的问题。
        ｜ 单级页表是一次性分配，所以每一项映射都要实实在在的存在的，所以可能额外分配了很多暂时不用的页表项。多级地址是离散的，在前一级没有用到的时候，后面的页表都不会创建。
        解决单级页表必须分配连续地址空间作为页表页的问题。
        ｜ 因为页表分配是要连续的地址空间，如果单级的话，会造成页表占用连续的地址空间过大，并且每一个程序都有自己的页表，也就意味着每一个程序都需要占用这么多连续的地址空间
        另外这个问题的第一个答案写的很好：多级页表到底解决什么问题

    转换逻辑
        前提为以二级页表举例
        假设现在最大有2^32个地址空间即4G，每个页表项映射一个页框，可以表示4K地址空间，那我们就需要100w个页表项表示这4G的地址，一个页表项又占了4B，数量跟一个的大小乘起来也就是需要4M的空间存这100w个页表项，页表是存在程序PCB中的并且页表是要一块连续的地址空间的，所以如果单级页表的话不管你有没有用到，只要程序启动就需要为程序分配4M的页表，不管程序有没有用到，但是像很多小程序，可能程序本身都没有4M，更用不到4M这么多的页表，无疑是一种浪费，并且这地址空间还要求是个连续的空间，那这也违反了我们做分页的将内存分配离散的目标，所以我们就想办法把一个4M的大页表打散。
        那我们怎么打散呢？我们给页表做个索引，即第一级索引的索引号 -> 第二级索引的地址，第二级索引的索引号 -> 具体数据的地址。那索引号是啥呢？我们不是有32位的虚拟地址么，因为需要表示4K的页内偏移量，所以有12位肯定是被offset字段给用了，我们还有20位表示我们的地址，那我们就可以用高10位表示第一级索引号，用低10位表示第二级索引号，10位正好是1024，第一级索引每个项表示4M的空间，第二级索引每个表示4K的空间
        ｜ 这里为什么10位拆一个索引呢，因为一个页表项占用4b空间，那一个页有4k，就可以装入1024个页表项，为了表示到1024个页表项，我们就需要用10位来表示。同理如果页表项占8位，页大小还是4k，那一个页就能装512个页表项，就可以用9位来表示一个页号
        整体逻辑为通过虚拟地址一级页号（虚拟地址前10位）从一级页表中拿到二级页表的内存页，用二级页号从二级页表中拿到数据的内存页，用这个内存页加上偏移量，就构成了数据的物理地址。

    aarch64架构下linux系统多级页表结构
        常见设置：64位架构下，需要8b表示一个页项，页项低48位参与地址翻译，页表为4级，虚拟页大小为4k。在此设置下，物理内存被划分为4k大小。
        48位的前36位，每9位为对应一级页号，后12位代表4k页面内的offset
        对于高16位，全为0表示用户程序使用，全为1表示系统程序使用，也就是说，当前架构下64位地址最大表示的范围是2^{48}byte


TLB（转址旁路缓存 Translation Lookaside Buffer）
    作用
        为了缓解引入多级页表造成的查询速度变慢，引入的一个缓存。
        TLB缓存虚拟页号到物理页号的关系，类似于哈希表，key是虚拟页号，value是物理页号。

    架构
        一般采用类似于CPU缓存的分层架构L1和L2，L1又分为指令TLB和数据TLB，L2一般不区分指令和数据

    刷新
        问题：TLB刷新的问题在于如何保证TLB与当前页表内容一致，并且性能又高。
        程序切换时主动刷新
            若操作系统在切换应用程序时刷新TLB，那程序开始执行时一定会出现未命中情况。

        在TLB上加程序ID
            多个程序同时共用一个TLB，在修改页表内容之后，操作系统需要主动刷新TLB，刷新方式可以根据CPU提供的方式如全部刷新，刷新指定TLB等方式来进行TLB的刷新



换页/缺页
    换页
        当物理内存容量不够时，操作系统应该把若干物理页的内容写到磁盘，回收这些物理内存页重新分配给需要的程序。把内存物理页写到磁盘中的过程被称为被换出。

    缺页
        换页的操作会把物理页的数据写到磁盘中，那虚拟页就是已分配但未映射的状态，当操作到这种状态的页时，触发操作系统预设的异常处理函数，操作系统会把之前写到磁盘的页再加载到内存物理页中，在虚拟地址的映射中填入该物理地址。这个过程被称为换入。

    缺页中断

    预取
        预取机制的思想是当发生换页操作时，预测哪些页有可能即将被访问，提前把这些页加载到内存中，减少缺页的发生。

    按需分配
        程序申请分配内存时，操作系统可以将新分配的虚拟页标记成已分配未映射，等到真正使用到这个页面时会触发缺页中断，到时候再将这个物理页和虚拟页的映射补齐，这个机制可以防止分配内存但不使用导致的内存占用。（没有分配，那数据存在哪呢？直接写到磁盘里面吗？）这个机制也会产生一个新问题，就是在第一次用到这个内存地址的时候会因为加载数据产生延迟。根据程序局部性特点，可以通过预取机制把临近的虚拟页也做完映射来改善。


页面置换策略
    作用
        因为页面一旦换出到硬盘后，再加载到内存非常耗时，所以需要提出一些策略来选择换出的页，保证换出的页短时间内不会被用到，以减少对性能的影响。
        页面替换策略是通过硬件提供的页面访问信息，来猜测哪些页被换走对性能的影响较低。

    具体策略
        MIN/OPT （最优策略 Minimum/Optimal）
            换出时，优先选择未来最长时间不会再访问的页。
            该算法无法实现，因为页访问顺序取决于应用程序，操作系统无法预先知道程序未来访问页的顺序
            这个算法主要作为一个标准衡量其他策略的优劣。怎么衡量呢？

        FIFO（先进先出 First-In First-Out）
            换出时选择最先换入的页进行换出。
            实现方式为操作系统维护一个队列，用于记录换入内存的物理页号，换入一个物理页就把这个物理页号加到队尾，换出时从队头拿页号换出。
            直观且开销低，但因为页换入的顺序与是否使用没关系，可能换出了接下来要使用的页，所以效果不加，现代系统不会直接使用。

        Second Chance
            在FIFO的基础上，增加一个标志位来表示这个页是否正在队列中，如果访问的页号已经在FIFO队列中就置上这个标志位。淘汰的时候还是优先队首，但是要看标志位是否置上了，如果置上了就把这个页号追加到队尾并且把标志位消掉，如果没置上直接淘汰掉该页号。
            这个策略的思想是假设页在被从磁盘换入内存之后，不止一次访问过的页是程序后面可能会用到的，所以通过一个标志位来表示这个物理页是否在这次加载到内存后不止一次被用到。这个策略因为考虑了访问信息，所以一般情况会优于FIFO，但在物理页每次加载到内存中后，在FIFO队列的这个长度下只被访问了一次这种场景下会退化成FIFO

        LRU（最久未被访问 Least Recently Used）
            换出时优先选择最久未被访问的页。思想是如果指令频繁访问，那后面可能也会频繁访问。
            操作系统维护一个链表，按照内存页访问顺序将内存页号插入链表尾部。每次访问后，操作系统将刚刚被访问的页调整到尾部，换出时从链表头部换出。

        MRU（最近被访问 Most Recently Used）
            换出时优先选择最近被访问的页。思想是程序不会反复访问相同的地址。

        时钟算法
            与second chance策略相似，但是把队列换成了一个类似于环形链表，有一个指针指向刚换入的页的后一个，当需要换出时，从指针位置开始找第一个没有置标志位的换出，如果碰见了置标志位的，把标志位清空。因为不需要


    工作集模式

