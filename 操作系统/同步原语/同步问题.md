问题
    使用同步原语会引入什么样的问题？
    我们该如何解决死锁？
    活锁与死锁的关系是什么？
    优先级反转和同步原语有什么关系？

死锁
    原因
        互斥访问
        持有并等待
        资源非抢占
        循环等待


死锁检测
    死锁检测的核心在于检测是否出现循环等待
    系统中有资源分配表和线程等待表，分别记录线程分配的资源情况和线程等待的资源情况。
    根据上面的两张表，可以构造出一个图，图中有环则说明发生了死锁。

检测策略
    由于死锁检测要构造出一个复杂的图，在图中找是否出现环，开销很大，所以一般选用定时检测或超时等待检测

死锁恢复
    要打破死锁，我们需要把图中的环打破，可以随机选择一个线程释放占有的资源，或者将系统倒退到之前的某一个状态继续执行。

死锁预防
    避免互斥访问
        将临界区资源的访问和修改都放到一个专门的线程中串行进行。程序复杂度高，开销大。

    不允许出现持有等待
        线程执行必须要拿到所有的资源，如果有资源没拿到，那就释放掉拿到的所有资源。竞争大时可能出现申请-释放循环

    允许资源抢占
        允许线程抢占其他线程占有的资源。需要保证被抢占资源的线程可以正确回滚到申请资源前的状态。一般用在数据库？

    避免循环等待
        给锁标一个优先级，加锁时必须按照优先级来获取锁资源。


死锁避免
    银行家算法
        思想
            以银行借贷系统分配策略为基础，判断并保证系统的安全运行。

        安全状态
            如果所有Process都可以完成并终止，则一个状态（如上述范例）被认为是安全的。

        具体实现
            allocation
                allocation[N][M]，固定的N个线程M类资源，allocation表示各个线程占用的每类资源的个数

            max
                max[N][M]，固定的N个线程M类资源，max表示各个线程最大占有的每类资源的个数

            need
                need[N][M]，固定的N个线程M类资源，need表示各个线程还需要的每类资源的个数

            available
                available[M]，固定的M类资源，availlable表示每类资源还可以分配的数量


        步骤
            虚拟出一个假available
            根据max-allocation算出need，再加一个字段finish，所有线程的该字段都是false
            根据need和available的比较，找到符合分配条件的线程，把资源分配给它再回收到available，把这个线程的finish字段置为true
            继续寻找下一个，以此类推，完成后当所有线程都为true时，当前系统为安全状态，可以把资源分配给



活锁
    在采用不允许持有等待策略来预防死锁时，出现的申请-释放循环被称为活锁。可以采用失败后随机等待时间的方式来减少活锁概率

优先级反转

