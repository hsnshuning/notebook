## 事务概念
需要保证ACID的一个或多个数据库操作叫做一个事务

## ACID
* 原子性（Atomicity）
    事务中的操作要么全做要么全不做。
* 隔离性（Isolation）
    其他事务的执行不会影响到自己的事务。
* 一致性（Consistency）
    数据库状态转换时，满足数据库的约束。
* 持久性（Durability）
    事务提交的结果不会丢失。
## 如何保证ACID
* 原子性通过undolog来保证。事务一旦回滚，记录就会通过记录中的roll_pointer指向undo页面的undolog，通过undolog形成的版本链回滚到原本的样子。
* 隔离性通过锁和MVCC来保证。当前读的时候如update语句，会对语句加锁，不允许其他事务进行当前读。快照读的时候通过MVCC来保证事务的隔离性。
* 持久性通过redolog来保证。通过写redolog保存页的改动，在崩溃时通过redolog把数据恢复到崩溃前的状态。


## 事务状态
* active：活动的，正在执行中的事务。
* partially committed：部分提交的，最后一个操作完成了但还没刷到磁盘。
* failed：失败的，事务遇到某些错误无法继续执行或被人为停止。
* aborted：中止的，回滚完的事务。
* committed：提交的，成功刷到磁盘的事务。

## 事务的分类
* 分类的意义
    1. 分离事务id，让读事务不占用读写事务ID， 记录中的trx_id指的是读写事务ID。
    2. 生成一致性读快照时，事务列表只包含读写操作事务ID
* 只读事务start transaction read only，只读事务没必要分配trx_id
* 读写事务start transaction read write，在第一次执行CUD操作时分配trx_id
## 事务ID
如果对表进行CUD操作，innodb引擎会给该事务分配唯一事务ID，事务ID类似于row_id的分配方式，有一个全局变量自增+表空间存储
### 事务ID分配时机
* 当使用start transaction with consistent snapshot语句开启事务时，在事务开启的同时分配事务ID。
* 当使用begin时，在执行到第一个语句时分配事务ID。
## 事务并发问题
* 脏写：一个事务更新了另一个事务未提交的数据。
* 脏读：一个事物读到了另一个事务为提交的数据。
* 不可重复读：一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。
* 幻读： 一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。

幻读问题出现在当前读的情况下，一致性读因为MVCC的原因，不会读到其他事务提交的数据。
## 隔离级别
* 读未提交 READ UNCOMMITTED（RU）
* 读已提交 READ COMMITTED（RC）
* 可重复读 REPEATABLE READ（RR）
* 串行化 SERIALIZABLE

什么时候选择可重复读呢？
不想因为读而阻塞改，并且希望一个事务中查询到的数据是一样的。
    