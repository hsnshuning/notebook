# 基于比较排序
## 冒泡
## 选择
## 插入
## 快排
快排思路是，先在数组中选出一个数p，和最右nums[r]调换位置，维护一个左边界lb一个右边界rb，左边界之中的是小于这个数的，初始值为最左-1即r-1，右边界之中是大于这个数的，初始值为最右即r。

从最左到右边界遍历数组，判断当前值nums[i]和被选中的数nums[r]的关系，小于nums[r]时左边界扩大即lb++，将nums[lb]和nums[i]调换位置并且i++。大于nums[r]时右边界扩大即rb--，将nums[rb]和nums[i]调换位置，但是因为调换后的nums[i]位置是一个没有被比较过的值，所以不能i++还需要继续判断nums[i]。等于nums[r]时，只进行i++，不进行边界扩大和交换。遍历完成后，左边界内都是小于nums[r]的，右边界内都是大于nums[r]的，左边界和右边界中间都是等于nums[r]的，将nums[r]和nums[rb]交换位置。

继续递归排序小于的即l到lb和大于的即rb+1到r，当数组元素个数拆分到2个的时候，执行完之后这两个元素就是有序的了，当数组拆分到只剩下一个时，递归就可以停止了。
```go
func quickSort(nums []int, l ,r int) {
    if l >= r {
        return 
    }
    p := rand.Int()%(r-l+1) + l
    v := nums[p]
    nums[r], nums[p] = nums[p], nums[r]
    lb, rb := l-1, r
    for i := l; i < rb; {
        if nums[i] > v {
            rb--
            nums[i], nums[rb] = nums[rb],nums[i]
        }else if nums[i] < v {
            lb++
            nums[i], nums[lb] = nums[lb], nums[i]
            i++
        }else {
            i++
        }
    }
    nums[rb], nums[r] = nums[r], nums[rb]
    quickSort(nums, l, lb)
    quickSort(nums, rb+1, r)
}
```
## 归并
归并排序的思路是，把数组按照一半一半来拆分，第一次拆分为2个，第二次把两个拆分为4个，一直拆分到只有1个元素的时候就不需要排序了直接返回。

返回到上一级就是有两个元素的时候左右两个分组本身只有一个元素，所以是有序的，但是左右两个分组是无序的，所以要进行排序，排序的方式为申请一个新数组，大小是2，然后从两个分组的最左侧遍历比较，两个分组中比较小的那个加到新数组中，遍历之后新数组就有序了，用新数组的数据替换掉旧数组的l到r的数据，旧数组的l到r就有序了，然后向上继续返回，可以理解为一个后序遍历吧，先把小分组给排了，然后再排大分组。
```go
func mergeSort(nums []int, l ,r int) {
    if r <= l {
        return 
    }
    arr := make([]int, r-l+1)
    mid := l + (r-l) >> 1
    mergeSort(nums, l, mid)
    mergeSort(nums, mid+1, r)
    p1, p2 := l, mid+1
    i := 0
    for ; p1 <= mid && p2 <=r; i++ {
        if nums[p1] <= nums[p2] {
            arr[i] = nums[p1]
            p1++
        }else {
            arr[i] = nums[p2]
            p2++
        }
    }
    for ;p1 <= mid;p1, i = p1+1,i+1 {
        arr[i] = nums[p1]
    }
    for ; p2 <= r; p2, i = p2+1, i+1 {
        arr[i] = nums[p2]
    }

    for idx := l; idx <= r; idx++ {
        nums[idx] = arr[idx-l]
    }
}
```

# 不基于比较排序
## 