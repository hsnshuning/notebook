sds简单动态字符串
    优点
        常量获取字符串长度
        避免缓冲区溢出
        减少字符串修改带来的是频繁重分配
        二进制操作安全

    sds头
    ｜ 为了节约头的空间并且保持数据的紧凑，把sds分为了5个类型，5，8，16，32，64分别对应了header中len和alloc字段的字节数，5没有alloc，长度用flags的高5位表示，只能存储长度小于32的字符串
        len 字符串长度
        alloc 最大长度
        flags 一些标记
        buf 

    扩容
        当前有效长度>=新增长度，返回
        更新之后，判断新旧类型是否一致
            一致使用s_realloc，否则使用s_malloc+s_free
            ｜ s_realloc会先尝试在原来的地方扩容，如果原来的地方没有这么多空闲空间了，就分配新的地址块，并搬迁数据
                当有效长度>=新增长度，返回


        增长步长
            新增后长度小于最大预分配长度(1024*1024=1M)，多分配一倍长度
            新增后长度大于等于最大预分配的长度，每次多分配预分配长度(减少不必要的内存)


    缩容
        缩容采用动态空间释放，不会立即使用内存重分配来回收缩短的字节，只进行移动和标记，并修改len，在tryObjectEncoding中真正删除


list 双向链表
｜ redis双向链表即普通的双向链表实现，不再使用
    ListNode
        prev *ListNode
        next *ListNode
        value *void
        ｜ void指针代表通用类型


zipList 压缩列表
    是redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。
    组成
        zlbytes 压缩列表占用的内存字节数，对我压缩列表进行内存充分配或者计算zlend的位置时使用。
        zltail尾节点距离起始位置的偏移量，单位字节。
        entry 压缩列表中的节点，保存一个字节数组或者一个整数
        zllen节点数量，最大为65535，当等于65535时需要遍历列表才能拿到len。entry节点。
        zlend标识结束。

    entry节点
        节点可以保存一个字节数组或一个整数值，字节数组分为长度小于63(2^6-1)字节，小于16383字节(2^14-1)，小于2^32-1字节三个类型，整数分为4位，1字节有符号，3字节有符号，int16，int32，int64。
        组成
            previous_entry_length前一个节点的长度，可以通过长度和指针运算，计算出前一个节点的起始地址，比如需要从表尾向表头遍历。如果前一个entry的长度小于254， 该字段占1字节，如果前一个节点的长度大于等于254，该字段占5字节，第一个字节固定为254，之后四字节用于保存前一个entry的长度
            encoding 记录节点content的数据类型及长度，以最高位两位和该字段的长度为区分。最高两位00，01，10表示字节数组，11表示整数
            content 节点的值，可以是字节数组或整数，类型和长度由encoding字段决定。


    连锁更新
        假设ziplist中所有entry的长度都是253字节，所以previous_entry_length字段都是1字节
        当在表头增加了一个长度大于254的元素，会导致原表头的previous_entry_length从1字节变为4字节，原表头元素长度变为257
        下一个元素继续更新，一直更新到最后
        删除节点的时候也有可能出现这种问题


dict 字典 
    结构图
    dict字典
        组成
            type：类型特定函数，dictType保存用于操作特定类型键值对的函数。
            privdata：私有数据，保存传给类型特定函数的可选参数。
            dictht：ht[2] 哈希表，一般只会用ht[0]，进行rehash时会同时使用ht[0]，ht[1]。
            rehashidx：记录rehash目前进度，没有进行rehash=-1。

        键冲突
            redis哈希表通过链地址法解决键冲突，并且为了速度考虑，程序总是将新节点添加到链表的表头位置

        rehash
            步骤
                1. 为ht[1]分配空间，大小取决于要执行的操作，分配空间是按照2 ^ n为单位，扩展操作为第一个大小大于等于ht[0].used * 2 的2 ^ n，收缩操作为第一个大小大于等于ht[1].used 的2^n。
                2. 将0中的键值对rehash到1上。3. 当0迁移到1结束后，释放0，将1置为0，在1上新建一个空白哈希表

            扩展操作：(负载因子>=1 && 没有在执行持久化操作) || (负载因子 >= 5)
            ｜ 负载因子：用来评估键冲突的概率
            ｜ ​在执行bgsave或bgrewriteaof的过程中，redis需要创建当前进程的子进程，而大多数操作系统采用写时复制技术优化子进程使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，尽可能避免在子进程存在期间进行哈希表扩展操作，避免不必要的内存写入操作
            收缩操作：负载因子 < 0.1进行收缩操作
            渐进式rehash
                避免rehash对服务器性能造成影响，rehash操作会分多次渐进式的进行。
                步骤：1. 分配1的空间，字典同时持有0和1两个哈希表。2. 字rehashidx = 0 表示正在rehash。3. 对字典执行CURD操作时，C会在1中进行，CURD会顺带将0表在rehashidx索引上的所有键值rehash到1中，然后rehashidx++。4. 当0中所有键都rehash到1中，设置rehashidx = -1
                URD操作会在两个哈希表上进行，0上没有找到，会在1上继续找一遍。C会直接在1中进行，保证了0中的键值只会减少不会增加。

            定时rehash
                为了防止没有请求进入，导致渐进式rehash一直无法完成rehash，redis会在serverCron中进行一部分rehash的操作
                时间为1ms一次，步长为100



    dictht字典哈希表
        组成
            table：dictEntry数组
            size：dictht数组大小
            sizemask：size掩码sizemask
            used：已有节点数

        负载因子
            计算公式：load_factor = ht[0].used / ht[0].size即负载因子 = 哈希表已保存的节点数量 / 哈希表大小

        键冲突
            redis哈希表通过链地址法解决键冲突，并且为了速度考虑，程序总是将新节点添加到链表的表头位置

        rehash
            步骤
                1. 为ht[1]分配空间，大小取决于要执行的操作，分配空间是按照2 ^ n为单位，扩展操作为第一个大小大于等于ht[0].used * 2 的2 ^ n，收缩操作为第一个大小大于等于ht[1].used 的2^n。
                2. 将0中的键值对rehash到1上。3. 当0迁移到1结束后，释放0，将1置为0，在1上新建一个空白哈希表

            扩展操作：(负载因子>=1 && 没有在执行持久化操作) || (负载因子 >= 5)
            ｜ 负载因子：用来评估键冲突的概率
            ｜ ​在执行bgsave或bgrewriteaof的过程中，redis需要创建当前进程的子进程，而大多数操作系统采用写时复制技术优化子进程使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，尽可能避免在子进程存在期间进行哈希表扩展操作，避免不必要的内存写入操作
            收缩操作：负载因子 < 0.1进行收缩操作
            渐进式rehash
                避免rehash对服务器性能造成影响，rehash操作会分多次渐进式的进行。
                步骤：1. 分配1的空间，字典同时持有0和1两个哈希表。2. 字rehashidx = 0 表示正在rehash。3. 对字典执行CURD操作时，C会在1中进行，CURD会顺带将0表在rehashidx索引上的所有键值rehash到1中，然后rehashidx++。4. 当0中所有键都rehash到1中，设置rehashidx = -1
                URD操作会在两个哈希表上进行，0上没有找到，会在1上继续找一遍。C会直接在1中进行，保证了0中的键值只会减少不会增加。

            定时rehash
                为了防止没有请求进入，导致渐进式rehash一直无法完成rehash，redis会在serverCron中进行一部分rehash的操作
                时间为1ms一次，步长为100



    dictEntry哈希表节点 
        组成：key，v，next，哈希表节点是一个单向链表


skipList 跳表
    作用
        跳表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针达到快速访问的目的，因为性能差距不大的情况下，实现复杂度比平衡树低很多，占用内存比平衡树要低，所以redis采用这种结构来代替平衡树，跳整体图例如下
        查询时间复杂度
            平均O(logN)
            最坏O(N)


    zskipList 跳表
        组成
            header：指向跳表头节点
            tail：指向跳表尾节点
            level：记录跳表中非表头的节点最大层数
            length：记录跳表中非表头节点的节点数量


    zskipListNode 跳表节点
        组成
            level：层数组，数组大小是1-32之间的随机数，在同一level相当于在同一条链表上，带有forward前进指针和span跨度两个属性。
                forward：前进指针指向下一个节点
                span：跨度，用于记录两个点间的距离。span的一个重要的功能是计算排位，在查找某个元素的过程中，走过的路径所有节点的span和就是这个节点的排位。

            backward：指针，指向当前节点的前一个节点，从表尾向表头遍历时使用。
            score：分值，节点是按照分值从小到大排列。
            ele：保存的值。分值相同按照对象在字典中的大小由小到大排序

        level数组生成
            redis的level数组数量选择了随机生成，随机算法为
            因为该随机算法，使得随机到越大的level数组大小的概率越低


    查找
        从头节点（虚拟头节点，不存数据）最高的层级开始往后查找，当遇到比查找元素大的就退回去到下一层向后查找，一直查找到最下面的一层。

    插入
        先走查找，查找到这个元素的位置。


intset 整数集合
    作用
        节省内存，intset是redis用于保存整数集合的数据结构，保存类型为int16，int32，int64的整数值并且保证不出现重复元素。intset是有序的，所以查找时间复杂度为logN

    组成
        encoding：定义了集合的类型，即16，32，64
        length：记录了整数集合包含的元素数量，即数组包含元素的数量
        contents：intset底层实现，intset每个元素都是contents的一个item，各项在数组中按值从小到大排列，数组中不包含重复item

    升级
        作用
            可以提升intset的灵活性，不需要关心到底存的是16，32，还是64，如果当前intset类型不满足新加入的元素的要求，自动进行升级以适配新加入的元素。
            升级可以节约内存，当只存16位的整数时，只需要分配16位的内存就可以了，需要32位时再自动升级到32位，尽量节约内存开销。

        步骤
            当发现当前类型不满足新元素的要求时（如类型是16位，但需要插入32位的元素），根据新元素的类型和已存在的item数量，计算出底层数组的大小，分配空间
            将现有元素转换为新元素的类型，并将转换后的元素放到正确位置，并维持底层数组的有序性
            将新元素添加到底层数组中


    降级
        intset不支持降级操作，一旦升级无法降级


quickList
    作用
        quickList是当前版本redis中list的唯一实现方式。zipList节省内存存储效率很高，但是每次改动会引发一次内存realloc。双向链表可以方便的进行改动，但是需要的内存空间较大。综合内存成本和改动成本，redis提出了quickList方案，quickList是双向链表结构，但每个node存储的是zipList，在从头尾修改数据的场景中使用比较合适。

    quickList
        组成
            head，tail：头，尾结点
            count：列表中所有entry的数量
            len：列表中所有quickListNode的数量
            fill：单个结点的填充因子，与list-max-ziplist-size参数有关，正数为zipList的最大元素个数，负数为zipList的最大字节数
            compress：结点的压缩深度，与list-compress-depth参数有关，0表示不压缩，1表示前后1个端点不压缩，2表示2个以此类推


    quickListNode
        组成
            prev，next：前后节点
            zl：指向一个ziplist
            sz：表示节点保存的ziplist的字节数
            count：表示item的数量
            encoding：是否被压缩，没有被压缩=1，lzf算法压缩=2
            container：是否直接存数据，1-直接存数据，2-打包存数据
            recompress：表示这个节点是否已经被压缩了
            attempted_compress：表示这个节点是否因为太小不能被压缩
            extra：保留位


    quickListEntry
        组成
            quicklist：指向entry所属的quicklist
            node：指向entry所属的quicklistEntry
            zi：指向ziplist
            value：指向当前zipList的字符串value成员
            longval：指向当前zipList的整形value成员
            sz：当前zipList的字节数
            offset：保存相对zipList的偏移量



