# 持久化
redis持久化分为两个部分，一个是RDB一个是AOF，RDB记录的是内存数据快照，可以理解为物理日志，通过直接加载数据来恢复数据。AOF是记录的是命令，通过执行命令来恢复数据。一般情况下是两者一起使用的。
# AOF
AOF是写后日志，先执行redis命令，把数据写入内存，再记录日志，整个过程在主线程中执行。AOF用的是write不同步fsync，不能保证数据不丢失，就算配置写回策略为always也是有丢数据的风险。

## 内容
1. AOF记录的是什么？
    * AOF日志记录的是执行的命令，这点类似于mysql的binlog，是逻辑日志。
2. 格式什么样？
    * set testkey testvalue这个命令对应的AOF大概是*3$3set$7testkey$9testvalue，即*命令数$命令的字节+数命令。


## 重写
AOF一直追加写一直追加写，文件会越来越大，所以redis通过提供AOF的重写机制来解决这个问题。redis通过后台fork出bgrewriteaof子进程来执行aof重写。

### 重新触发条件
1. 手动触发bgrewriteaof命令
2. 自动触发`auto-aof-rewrite-min-size`和`auto-aof-rewrite-percentage`两个参数。计算方式为`aof_current_size>auto-aof-rewrite-minsize`和` (aof_current_size-aof_base_size)/aof_base_size>=auto-aof-rewritepercentage`
### 流程
1. redis主进程fork出bgrewriteaof子进程来执行aof重写。
2. bgrewriteaof读内存中所有数据，一条数据对应一条命令。比如一个kv数据`testkey：testvalue`，就会记录一个`set testkey testvalue`这样的命令,`*3$3set$7testkey$9testvalue`。
3. 在执行aof重写过程中redis收到一个新写入命令时，会写两份aof，一份老的aof日志继续追加，还会在内存中维护一份新aof文件的数据，用于在aof重写完成后，将这些内存中的数据写到新aof文件里，避免这段时间的修改丢失。


## 问题
1. 为什么是写后日志？
    * **防止恢复的时候出错**。redis在执行之前不会进行预检查，先写日志再执行命令，可能会记录错误的命令，通过日志恢复数据时会出错。
    * **考虑性能**。在命令执行后记录日志不会阻塞当前的操作。
2. 写后日志有什么问题？
    * 丢失日志数据，比如没有写日志就宕机了。
    * 因为写日志是在主线程中执行，如果写入时磁盘压力大写入的慢，会阻塞后面的操作。
3. 如何避免宕机AOF日志丢失的问题？
    * **配置写回策略**。即appendfsync的配置
        * always：同步写回，每个写命令执行完，立马同步将日志写回磁盘
            * 优点：可以做到基本不丢数据，极端情况下会丢失少部分数据。
            * 缺点：每一个写命令都会落盘，会影响主线程性能。
        * everysec：每秒写回，命令执行完，先把日志写到AOF文件的内存缓冲区，每秒把缓冲区的内容写入磁盘。
            * 优点：避免了同步写回的性能影响
            * 缺点：一旦宕机，可能会丢失数据，1秒内的数据就丢失了
        * no：操作系统控制，命令执行完，先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。
            * 优点：避免了同步写回的性能影响
            * 缺点：一旦宕机，未落盘的数据就都丢失了，丢失的量可能最大
3. AOF文件一直追加写操作，文件会越来越大，有什么影响？
    * 文件系统本身对文件大小有限制，无法保存过大的文件
    * 文件太大对追加的效率会有影响
    * 宕机后恢复数据需要一个一个执行命令，AOF文件过大会延长恢复时间
4. 如何避免AOF文件过大？AOF重写机制
    * AOF重写机制是根据当前数据库现状创建一个新的AOF文件，即读取所有键值对，对每个键值对用一条命令记录。
5. 为什么重写可以解决AOF文件过大？
    * 比如一个经常更新的key，原来需要100个命令set这个key，现在只需要根据当前redis中这个key的值来写一个set命令即可。
6. AOF重写会带来什么问题？
    * AOF是由主线程fork出bgrewriteaof线程，同时进行了内存数据的拷贝，对内存和机器运行效率有影响
    * 在AOF重写期间，日志文件会写两份，一份是原AOF文件，一份是新AOF文件，会增加磁盘IO

## 配置
1. appendonly。AOF写回策略，write。
2. appendfilename。aof文件名。
3. appendfsync。AOF同步策略，fysnc。

# RDB
RDB即redis database的缩写，相当于内存状态的快照。把某一时刻的状态以文件的形式写到磁盘上。和AOF相比，RDB记录的是某一时刻的数据，所以在恢复时可以直接读入内存，会很快完成恢复。rdb是经过压缩的。因为rdb是物理日志而不是aof这种需要重新执行的逻辑日志，所以rdb用来恢复数据会比aof快。

## 触发方式
1. 通过save命令和bgsave命令。
2. 配置redis.config中的配置自动执行。
3. 通过主从复制触发。


## 流程流程
1. redis调用fork创建一个子进程。
2. 子进程将当前数据写入一个临时RDB文件中。
3. 写入完成后，redis用临时rdb文件替换原来的rdb文件。

## 问题 
1. fork子进程的过程会阻塞主进程，所以也无法频繁进行RDB存储
2. 在存储过程中，如果修改了主进程中的一个键，redis会创建一个该键值对的副本，在写入比较多的情况下，如读写比为2:8的情况下，可能会占用大量内存。
3. 在两次save操作中间进行写操作的数据，是无法通过RDB文件进行恢复的。


## 配置参数
1. save。`save 900 1`表示900s内至少1条修改，就做RDB。不想用的话就用`save ""`来禁用RDB。
2. stop-writes-on-bgsave-error。当最后一次 RDB 持久化保存文件失败后，拒绝接收数据。
3. rdbcompression。rdb压缩。
4. rdbchecksum。通过crc64进行数据校验。
5. dbfilename。rdb文件名。
6. dir。文件所在文件夹。


# RDB+AOF混合持久化
redis支持同时使用rdb和aof进行持久化。这种情况下如果重启的话会优先选择AOF进行恢复。