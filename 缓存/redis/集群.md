# redis集群模式
集群模式是redis的分布式方案，通过分片的方式来进行数据共享，并提供复制和故障转移的能力。

# 官方集群
redis官方提供的集群方案。
## 集群搭建方法
1. 配置文件中的`cluster-enabled yes`开启集群模式。
1. 通过`CLUSTER MEET <ip> <port>`命令让当前节点和指定IP端口的节点进行**握手**。


## 集群握手流程
1. 节点B给节点A发送消息CLUSTER MEET命令。
2. 收到CLUSTER MEET命令后A节点会创建一个clusterNode来保存B节点的信息，并把这个信息放到ClusterState的nodes中维护，然后向B节点发送MEET。
3. B收到A的MEET后同样会创建A的clusterNode并放在nodes中。之后B向A发送PONG消息通知A已经收到MEET信息。
4. A节点收到PONG后回一个PING。B节点收到PING命令，握手完成。
6. A节点通过gossip协议把B的信息传播给集群中其他节点，让其他节点与B进行握手，经过时间后B节点会与其他集群中的节点全部建立连接。

## 集群状态
集群中有16384个槽，集群中每个节点对应0～16384个槽位。根据这16384个槽位是否都有节点处理，把集群分为上线和下线两个状态。
* 上线状态：这16384个槽位都有节点处理。
* 下线状态：有槽位没有被节点处理。
我们可以通过CLUSTER INFO命令来查看redis集群的信息。

## 槽指派
我们可以通过`CLUSTER ADDSLOTS 0 1 2 3 ... 5000`命令，将0到5000的槽指派给某一个节点。

## 重新分片数据迁移
在使用集群的过程中我们很有可能会增加或删除集群节点，在这个过程中，我们要为节点重新分配slot，这时我们要将原来的数据迁移到新节点之上，这个过程是通过redis-trib工具来执行的，redis-trib相当于两个节点之间的调度者，假设我们要把A库的数据迁移到B库，流程如下。
1. redis-trib给B库发送`CLUSTER <slot> IMPORTING <source_id>`命令，让B库准备接收slot槽中的数据。
2. redis-trib给A库发送`CLUSTER SETSLOT <slot> MIGRATING <target_id>`命令，让A库准备将slot槽中的数据发送给B库。
3. redis-trib给A库发送`CLUSTER GETKEYSINSLOT <slot> <count>`命令，获取slot槽中count个数据。
4. redis-trib给A库发送`MIGRATE <target_ip> <target_port> <key_name> 0 <timeout>`命令，把数据原子的从A库迁移到B库。0表示迁移到0号库，官方集群方案中集群节点只能使用0号库。
5. 重复3、4步骤，直到数据全部迁移完成。
6. 数据迁移完成后，redis-trib会给集群中任意一个节点发送`CLUSTER SETSLOT <slot> NODE <target_id>`命令，将slot槽指派B节点。

redis集群做数据迁移的过程中是不会阻塞slot上的用户请求的，所以当用户请求slot槽中的数据时，就需要在两个库中进行查询，这样的话就需要有一个重定向的流程，流程如下。
1. A库收到获取slot槽中key1的请求，先在自己的库中进行查找，查找到了直接返回给客户端。
2. 如果A库没有在自己的库中查找到，那就给客户端返回一个ASK错误，其中包含槽、B库的ip和port信息。
3. 客户端收到ASK错误时，根据上面提供的IP和PORT向B节点发送ASKING命令让B节点执行这个客户端的命令，然后给B库发送获取key1的请求。
步骤3中发送ASKING命令是为了让B库执行客户端的命令，因为B库在迁移过程中还没有被指派到slot槽，正常情况下如果B库收到了slot槽的请求，是会通过MOVED命令将这个请求指向A库的，这样A库和B库就循环了，通过ASKING命令，让B库**强制执行一次**这个客户端的操作。





## 集群结构
集群中的每个节点会维护一个ClusterState结构，结构里面有epoch，当前集群状态以及保存集群中其他节点状态的clusterNode的dict。clusterNode会记录集群中节点的IP，PORT，slots等信息。slots是一个位数组，长度是2048个字节，可以表示16384个槽是否被占用。各个节点都会向其他节点通知自己所负责的槽信息，各个节点也都存储了其他节点的槽信息。同时为了高效查找某个slot对应的node节点，每个节点的clusterState结构中也存储了每个槽对应到的clusterNode，从而避免遍历整个nodes从每个node上面再遍历一遍slots数组来查找。

## 客户端与集群的交互
1. 客户端向集群某节点发送命令。
2. 节点收到命令，查看是否是自己的槽，如果是自己的槽执行命令即可，如果不是自己的槽要给客户端发送MOVED命令，让客户端进行重定向。


## MOVED命令和ASK命令的区别
在命令的意思上来说，接收到moved命令说明这个槽没有分配到这个节点，需要到其他节点去找。接受到ask命令说明这个槽现在确实分配给了这个节点，但是这个节点上没有这个数据，而且这个节点正在做数据迁移，这个数据可能被迁移到别的节点上去了，需要去问问那个节点。在使用上来说，接收到MOVED命令其实算是一个永久重定向，接收到ASK命令是一个临时重定向，只能用一次。

## 集群主从
redis集群中的节点是支持一主多从的，通过命令`CLUSTER REPLICATE <node_id>`来配置主节点。执行的逻辑和单机的slaveof基本一致，执行完成后从节点会向集群里面的其他节点发送自己的状态信息，收到信息的其他节点会在保存了对应主节点的ClusterNode的slaves属性中记录这个从节点的ClusterNode，随着信息的传播最终集群中所有节点都会知道这个信息。

## 集群故障检测
集群中的每个主节点都会定期向集群中的其他节点发送PING命令来检测对方是否在线，如果对方没有在规定的时间内回复PONG，就将这个节点标记为疑似下线，同时向节点中的其他节点发送这个节点疑似下线的消息。当主节点收到其他主节点发来的疑似下线的消息时，这个主节点会把疑似下线的主节点标记为下线报告，意思就是收到了这个节点的疑似下线报告了。然后在clusterNode的fail_reports链表中保存这个报告。当集群中有半数的负责处理槽的主节点都标记了某个主节点疑似下线，这个节点就会被标记为下线。标记这个节点下线的节点会在集群中广播这个消息，准备开始执行故障转移。

## 集群故障转移


# codis