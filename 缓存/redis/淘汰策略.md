淘汰策略
    进行数据淘汰
        设置过期时间的数据
            random：随机删除
            ttl：越早过期的越先被删除
            lru：使用LRU算法筛选
            lfu：使用LFU算法筛选

        所有数据
            random：随机
            lru：LRU算法
            lfu：LFU算法


    不进行数据淘汰
        noevction：当缓存被写满，不会淘汰数据，再有写请求来的时候直接返回错误


策略算法
    LRU：Least Recently Used 最近最少使用，淘汰最近最久未使用的数据
        经典LRU实现原理
            维护一个所有数据的链表，头和尾分别是MRU最常使用和LRU最不常用的数据
            当访问到一个数据时，将该数据放入MRU端
            需要淘汰数据时，从LRU端进行数据淘汰

        经典LRU存在的问题
            链表的额外空间的开销
            如果有大量数据被访问，数据在链表移动会很耗时，降低性能

        Redis中的实现
            记录每个数据最近一次访问的时间戳（RedisObject的lru字段）
            第一次随机选择N个数据作为候选集合
            比较这N个数据的LRU字段，LRU字段值最小的淘汰
            再次淘汰数据时，挑选新数据进入第一次的候选集合，规则为该数据的LRU字段值必须小于集合中最小的LRU
            当候选数据集的数据量达到了设置的样本数据量时，再次把LRU字段最小的数据淘汰掉

        对比经典LRU的优缺点
            优点
                在空间和准确率之间进行权衡，采用采样方式而不是全量数据链表的方式，所以没有维护大链表的空间开销
                没有维护大链表，所以也不用在每次访问时都进行链表的移动操作，减少时间开销

            缺点
                由于是采样，会有一定误差


        相关配置
            maxmemory-samples：控制redis选择多少个数据，即上面的N，例如设置比较数据集的数据量为100：CONFIG SET maxmemory-samples 100


    LFU：Least Frequently Used 最不常使用，对LRU算法进行优化，记录访问次数，淘汰访问次数最少的，当访问次数相同，淘汰最久未使用的
        经典LFU算法实现原理
            维护一个链表，该链表从头到尾大体是根据访问次数由大到小的次序进行排序。
            由于访问次数可以相同，相同访问次数的节点就在链表中组成了一个区域，在该区域中，节点从头到尾的次序是根据访问时间由近到远进行排序的。
            当访问到一个数据时，将该数据的访问次数+1，因为访问次数的改变，该数据需要从旧位置移动到新访问次数区域，作为新区域的头节点
            当需要进行淘汰时，队尾的数据是访问次数最小且访问时间最久的数据，所以淘汰队尾的数据即可

        经典LFU算法的问题
            链表额外空间的开销
            在链表中移动数据的性能开销
            当一个数据短时间有大量访问，之后就不再访问了，按照LFU来淘汰的话可能该数据永远不会被淘汰掉

        Redis中的实现
            采用LFU策略时，会将LRU字段拆分成两部分，前一部分16bit表示时间戳单位为分钟级别，后一部分8bit表示访问次数
            对于访问次数的更新，并不是每次都+1，而是根据一定算法进行计算，满足条件才会+1，该算法保证了当访问次数越大，+1的概率越小
                计算访问次数*lfu_log_factor + 1，再取倒数，得到值P
                取0到1之间的随机数，当P大于随机数时，进行+1操作

            通过随机采样的方式，选取N个数据组成候选集合
            根据LRU字段值的大小进行筛选，淘汰该字段小的
            为了避免出现有数据的访问次数很大，导致一直不会淘汰该数据的问题，Redis设计了counter值衰减机制
                redis提供配置项lfu_decay_time，表示多少分钟没有访问会衰减1
                redis将当前时间和数据的最近一次访问时间的差值换算成分钟M
                用M除以lfu_decay_time值，得出衰减值


        对比经典LFU算法优缺点
            优点
                在空间和准确率之间进行权衡，采用采样方式而不是全量数据链表的方式，所以没有维护大链表的空间开销
                没有维护大链表，所以也不用在每次访问时都进行链表的移动操作，减少时间开销

            缺点
                由于是采样，会有一定误差
                衰减时，可能会出现访问时间在同一时间的数据，热点数据先被衰减了




过期策略
    定期删除
    惰性删除
    触发清理条件

