# 基本原理
通过多级缓存，将对象根据大小分类，按照类别分配内存。多级缓存是为了减少锁冲突，如果每个线程都用页堆来分配内存，那锁冲突将非常严重，所以通过每个线程独立的缓存，中心缓存，页堆这三层，来减少锁冲突的概率。

# 内存单元
go语言的内存是以mspan的方式来管理的，每个mspan管理若干个8K的页，有67个固定大小的mspan类型和1个用于给大对象分配内存的0类mspan。span和span之间会串成一个链表存储在对应的分级缓存中。mspan有一个指向开始页的ptr和页数。

# 对象大小分类
go语言将对象按照大小分为微，小，大三类。
1. 微对象：16B以下
2. 小对象：16B-32KB
3. 大对象：32KB以上

## 微对象
主要用来分配小字符串和逃逸的临时变量，会将多个小对象放在同一个内存块，所有的小对象都回收才会回收内存块，是否有溢出的风险？会重用内存块，应该不会有溢出的风险吧。

# 内存多级缓存
go语言将内存分为线程缓存thread cache、中心缓存central cache、页堆heap三类
1. 线程缓存thread cache：属于每个线程的，绑定在P上面，用于分配微小对象，不足时使用中心缓存分配小对象，大对象直接分配在堆上。
2. 中心缓存central cache：所有线程共用的，共有134个中心缓存，即67*2。
3. 页堆heap：持有central cache，heapArena，allmspan

## 线程缓存
线程缓存绑定在P上，主要用于分配微小对象，每个mcache持有$68*2$个mspan，当有需要的时候根据对象大小向对应类型的mcentral获取。同时mcache中还存在一个微分配器，一般为16B，专门用于微对象分配。**分配器不需要关心满了的mspan，只要有空闲的mspan可以分配内存就行，所以当对应class的mspan满了，就直接用新的替换掉。**

## 中心缓存
go语言运行时共有136个mcentral，在堆init的时候进行初始化，每个mcentrial属于一个spanClass，4个spanSet，2个有空位的set，2个满了的set，mcache通过mcentral来获取

## 页堆
go语言运行时有一个全局的mheap用来管理堆内存，它持有一个heapArena二维数组表示所有分配到堆中的内存每个代表64M内存，还持有136个mcentral，68个scan，68个noscan

## 从中心缓存获取span
流程：大致就是先从有空闲空间的里面拿，先看有碎片的，再看没碎片的，都没有的话就看看能不能清理出来一个空间，都不行那就只能申请新内存了。
1. 从被清理过，包含空闲空间的spanSet中拿可用的span。
2. 从未被清理过，包含空闲空间的spanSet中拿可用span。
3. 从不包含空闲空间，未被清理过的spanSet中拿span并且通过sweep清理内存。
4. 从页堆申请新mspan。
5. 更新allocCache字段。
