# 基本原理
通过多级缓存，将对象根据大小分类，按照类别分配内存。

# 内存单元
go语言的内存是以mspan的方式来管理的，每个mspan管理若干个8K的页，有67个固定大小的mspan类型和1个用于给大对象分配内存的0类mspan。

# 对象大小分类
go语言将对象按照大小分为微，小，大三类。
1. 微对象：16B以下
2. 小对象：16B-32KB
3. 大对象：32KB以上

## 微对象
主要用来分配小字符串和逃逸的临时变量，会将多个小对象放在同一个内存块，所有的小对象都回收才会回收内存块，是否有溢出的风险？会重用内存块，应该不会有溢出的风险吧。

# 内存多级缓存
go语言将内存分为线程缓存thread cache、中心缓存central cache、页堆heap三类
1. 线程缓存thread cache：属于每个线程的，绑定在P上面，用于分配微小对象，不足时使用中心缓存分配小对象，大对象直接分配在堆上。
2. 中心缓存central cache：所有线程共用的，共有134个中心缓存，即67*2。
3. 页堆heap：持有central cache，heapArena，allmspan

## 线程缓存
线程缓存绑定在P上，主要用于分配微小对象，每个mcache持有$68*2$个mspan，当有需要的时候根据对象大小向对应类型的mcentral获取。

## 中心缓存
go语言运行时共有136个mcentral，在堆init的时候进行初始化，mcentral维护全局的mspan，mcache通过mcentral来获取

## 页堆
go语言运行时有一个全局的mheap用来管理堆内存，它持有一个heapArena二维数组表示所有分配到堆中的内存每个代表64M内存，还持有136个mcentral，68个scan，68个noscan

## 从中心缓存获取span
流程：大致就是先从有空闲空间的里面拿，先看有碎片的，再看没碎片的，都没有的话就看看能不能清理出来一个空间，都不行那就只能申请新内存了。
1. 从被清理过，包含空闲空间的spanSet中拿可用的span。
2. 从未被清理过，包含空闲空间的spanSet中拿可用span。
3. 从不包含空闲空间，未被清理过的spanSet中拿span并且通过sweep清理内存。
4. 从页堆申请新mspan。
5. 更新allocCache字段。



