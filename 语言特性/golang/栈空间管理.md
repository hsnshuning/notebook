# 栈
栈区存放的数据是一些局部变量，这种数据一般不会长时间存在，分配和回收由编译器完成。

# 栈寄存器
go有两个栈寄存器，BP和SP，BP存储栈的基地址指针，SP存储栈顶地址。申请和释放栈内存的时候只需要修改SP指针即可。

# 线程栈
每个线程是程序执行的上下文，所以每个线程有自己的BP和SP，当进行线程切换时这些上下文会被切换。线程栈大小一般为2M到4M

# 内存逃逸
内存逃逸分析的目的是决定分配在栈上还是堆上。
## 逃逸分析不变性
逃逸分析是指由编译器决定内存分配的位置。为了保证程序的安全性，内存分配需要满足以下不变性
1. 指向栈对象的指针不能存在于堆中。
2. 指向栈对象的指针不能在该对象回收后存活。

## 逃逸场景
1. 局部变量指针逃逸。
2. 栈空间不足逃逸。
3. 动态类型逃逸。interface类型的参数在编译期难以确定参数具体类型，所以会逃逸。
4. map，slice，chan返回逃逸。

# G栈内存空间

## 分段栈
以链表形式组织的栈空间，存在热分裂问题。
## 连续栈
以连续空间组织的栈空间，扩容时分配更大的栈把数据复制过去，将旧栈对应变量的指针重新指向新栈，虽然增加了扩容的开销，但以此为成本解决了热分裂问题。缩容的过程放到了GC期间进行，当栈内存使用不足1/4就缩一半的栈内存。

## 栈内存分层
跟堆内存一样，栈内存空间为了防止线程并发也用了分层的方式，在每个mcache中都有自己的栈内存缓存以减少锁冲突，同时还有stackpool和stacklarge两个全局变量来给所有线程分配内存，stackpool分配小于等于32KB的，stacklarge分配大于32KB的。栈内存也是通过mspan来进行管理的，最终也是从堆上申请的。

